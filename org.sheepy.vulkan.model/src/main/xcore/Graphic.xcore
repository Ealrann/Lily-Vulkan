@GenModel(modelDirectory="/org.sheepy.vulkan.model/src/generated/java")
@GenModel(editDirectory="/org.sheepy.vulkan.model.edit/src/generated/java")
@GenModel(publicConstructors="true", complianceLevel="11.0", resource="XMI")
@GenModel(extensibleProviderFactory="true", childCreationExtenders="true")

package org.sheepy.vulkan.model.process.graphic

import org.sheepy.common.model.types.SVector2i
import org.sheepy.vulkan.model.ColorDomain
import org.sheepy.vulkan.model.enumeration.EAttachmentLoadOp
import org.sheepy.vulkan.model.enumeration.EAttachmentStoreOp
import org.sheepy.vulkan.model.enumeration.EBlendFactor
import org.sheepy.vulkan.model.enumeration.EBlendOp
import org.sheepy.vulkan.model.enumeration.ECullMode
import org.sheepy.vulkan.model.enumeration.EDynamicState
import org.sheepy.vulkan.model.enumeration.EFrontFace
import org.sheepy.vulkan.model.enumeration.EImageLayout
import org.sheepy.vulkan.model.enumeration.ELogicOp
import org.sheepy.vulkan.model.enumeration.EPipelineStage
import org.sheepy.vulkan.model.enumeration.EPolygonMode
import org.sheepy.vulkan.model.enumeration.EPresentMode
import org.sheepy.vulkan.model.enumeration.ESampleCount
import org.sheepy.vulkan.model.process.AbstractPipeline
import org.sheepy.vulkan.model.process.AbstractProcess
import org.sheepy.vulkan.model.process.Configuration
import org.sheepy.vulkan.model.process.IPipeline
import org.sheepy.vulkan.model.process.PipelineBarrier
import org.sheepy.vulkan.model.resource.DepthImage
import org.sheepy.vulkan.model.resource.Image
import org.sheepy.vulkan.model.resource.ImageBarrier
import org.sheepy.vulkan.model.resource.Shader

class GraphicConfiguration extends Configuration
{
	boolean clearBeforeRender = "true"
	EPresentMode presentationMode = "MailBox"
	int swapImageUsage = "16" // EImageUsage.ColorAttachment
	EPipelineStage frameWaitStage = "COLOR_ATTACHMENT_OUTPUT_BIT"
	contains ColorDomain colorDomain
}

class RenderPassInfo
{
	contains AttachmentDescription[] attachments
	contains SubpassDependency[] dependencies
	int bindPoint = "0"
}

class SubpassDependency
{
	int srcSubpass = "-1"
	int dstSubpass = "0"
	EPipelineStage srcStageMask = "COLOR_ATTACHMENT_OUTPUT_BIT"
	EPipelineStage dstStageMask = "COLOR_ATTACHMENT_OUTPUT_BIT"
	int srcAccessMask = "0"
	int dstAccessMask = "0"
}

class AttachmentDescription
{
	boolean stencil = "false"
	ESampleCount samples
	EAttachmentLoadOp loadOp
	EAttachmentStoreOp storeOp
	EAttachmentLoadOp stencilLoadOp
	EAttachmentStoreOp stencilStoreOp
	EImageLayout initialLayout
	EImageLayout finalLayout
	// For attachment ref
	EImageLayout refLayout
}

class GraphicProcess extends AbstractProcess
{
	contains GraphicConfiguration configuration
	contains RenderPassInfo renderPassInfo
	contains DepthImage depthImage
}

interface IGraphicsPipeline extends IPipeline
{
}

interface IGUIPipeline extends IGraphicsPipeline
{
}

abstract class GraphicsPipeline extends AbstractPipeline, IGraphicsPipeline
{
	refers Shader[] shaders
	contains ViewportState viewportState
	contains Rasterizer rasterizer
	contains ColorBlend colorBlend
	contains DynamicState dynamicState
}

class DynamicState
{
	EDynamicState[] states
}

class ColorBlend
{
	contains ColorBlendAttachment[] attachments
	boolean logicOpEnable = "false"
	ELogicOp logicOp = "COPY"
	int blendConstant0 = "0"
	int blendConstant1 = "0"
	int blendConstant2 = "0"
	int blendConstant3 = "1"
}

class ColorBlendAttachment
{
	boolean blendEnable = "false"
	boolean redComponentEnable = "true"
	boolean greenComponentEnable = "true"
	boolean blueComponentEnable = "true"
	boolean alphaComponentEnable = "true"
	EBlendFactor srcColor = "ONE"
	EBlendFactor dstColor = "ZERO"
	EBlendFactor srcAlpha = "ONE"
	EBlendFactor dstAlpha = "ZERO"
	EBlendOp colorBlendOp = "ADD"
	EBlendOp alphaBlendOp = "ADD"
}

interface ViewportState
{
}

class StaticViewportState extends ViewportState
{
	contains Viewport[] viewports
	contains Scissor[] scissors
}

class DynamicViewportState extends ViewportState
{
	int viewportCount
	int scissorCount
}

class Viewport
{
	SVector2i offset = "0, 0"
	// If null, will use the swapchain image size
	SVector2i extent
	int minDepth = "0"
	int maxDepth = "1"
}

class Scissor
{
	SVector2i offset = "0, 0"
	// If null, will use the swapchain image size
	SVector2i extent
}

class Rasterizer
{
	ECullMode cullMode = "BACK_BIT"
	EFrontFace frontFace = "CLOCKWISE"
	EPolygonMode polygonMode = "FILL"
	int lineWidth = "1"
	boolean depthClampEnable = "false"
	boolean discardEnable = "false"
	boolean depthBiasEnable = "false"
}

class ImagePipeline extends AbstractPipeline
{
	refers Image[1..1] image
	EPipelineStage imageSrcStage
	EPipelineStage imageDstStage
	int imageSrcAccess = "0"
	int imageDstAccess = "0"
}

class PipelineImageBarrier extends PipelineBarrier
{
	contains ImageBarrier imageBarrier
}
