@GenModel(cleanup="true", codeFormatting="true")
@GenModel(modelDirectory="/org.sheepy.lily.vulkan.model/src/generated/java")
@GenModel(editDirectory="/org.sheepy.lily.vulkan.model.edit/src/generated/java")
@GenModel(publicConstructors="true", complianceLevel="11.0", resource="XMI")
@GenModel(extensibleProviderFactory="true", childCreationExtenders="true")
@GenModel(updateClasspath="false")
package org.sheepy.lily.vulkan.model.process.graphic

import org.sheepy.lily.core.model.types.Color4f
import org.sheepy.lily.core.model.types.LNamedElement
import org.sheepy.lily.core.model.types.Vector2i
import org.sheepy.lily.vulkan.model.ColorDomain
import org.sheepy.lily.vulkan.model.enumeration.EAccess
import org.sheepy.lily.vulkan.model.enumeration.EAttachmentLoadOp
import org.sheepy.lily.vulkan.model.enumeration.EAttachmentStoreOp
import org.sheepy.lily.vulkan.model.enumeration.EBlendFactor
import org.sheepy.lily.vulkan.model.enumeration.EBlendOp
import org.sheepy.lily.vulkan.model.enumeration.ECullMode
import org.sheepy.lily.vulkan.model.enumeration.EDynamicState
import org.sheepy.lily.vulkan.model.enumeration.EFrontFace
import org.sheepy.lily.vulkan.model.enumeration.EImageLayout
import org.sheepy.lily.vulkan.model.enumeration.EImageUsage
import org.sheepy.lily.vulkan.model.enumeration.ELogicOp
import org.sheepy.lily.vulkan.model.enumeration.EPipelineStage
import org.sheepy.lily.vulkan.model.enumeration.EPolygonMode
import org.sheepy.lily.vulkan.model.enumeration.EPresentMode
import org.sheepy.lily.vulkan.model.enumeration.ESampleCount
import org.sheepy.lily.vulkan.model.process.AbstractPipeline
import org.sheepy.lily.vulkan.model.process.AbstractProcess
import org.sheepy.lily.vulkan.model.process.Configuration
import org.sheepy.lily.vulkan.model.process.IPipeline
import org.sheepy.lily.vulkan.model.resource.Image
import org.sheepy.lily.vulkan.model.resource.Shader
import org.sheepy.lily.vulkan.model.enumeration.EPrimitiveTopology
import org.sheepy.lily.core.model.types.Vector3d

class GraphicConfiguration extends Configuration
{
	contains SwapchainConfiguration[1..1] swapchainConfiguration
	contains FramebufferConfiguration[1..1] framebufferConfiguration
	@GenModel(propertyDescription="The stage on which we should wait until acquire the next image")
	EPipelineStage acquireWaitStage = "COLOR_ATTACHMENT_OUTPUT_BIT"
	contains ColorDomain[1..1] colorDomain
}

class SwapchainConfiguration
{
	EPresentMode presentationMode = "MailBox"
	int requiredSwapImageCount = "3"
	unique EImageUsage[] swapImageUsages
	contains ISwapAttachment[] atachments
}

class FramebufferConfiguration
{
	Color4f clearValue = "0;0;0;0"
}

interface ISwapAttachment
{
}

class ImageAttachment extends ISwapAttachment
{
	Color4f clearValue = "0;0;0;0"
	refers Image imageRef
}

class DepthAttachment extends ISwapAttachment
{
	boolean clear = "true"
}

class RenderPassInfo
{
	contains AttachmentDescription[] attachments
	contains Subpass[] subpasses
	contains SubpassDependency[] dependencies
	int bindPoint = "0"
}

class Subpass
{
	String name
	contains AttachementRef[] refs
}

class AttachementRef
{
	refers AttachmentDescription attachement
	EImageLayout layout
}

class SubpassDependency
{
	refers Subpass srcSubpass
	refers Subpass dstSubpass
	unique EPipelineStage[] srcStageMask
	unique EPipelineStage[] dstStageMask
	unique EAccess[] srcAccesses
	unique EAccess[] dstAccesses
}

abstract class AttachmentDescription extends LNamedElement
{
	ESampleCount samples
	EAttachmentLoadOp loadOp
	EAttachmentStoreOp storeOp
	EAttachmentLoadOp stencilLoadOp
	EAttachmentStoreOp stencilStoreOp
	EImageLayout initialLayout
	EImageLayout finalLayout
}

class SwapImageAttachmentDescription extends AttachmentDescription
{
}

class ExtraAttachmentDescription extends AttachmentDescription
{
	refers ISwapAttachment[1..1] attachment
}

class GraphicProcess extends AbstractProcess
{
	contains GraphicConfiguration[1..1] configuration
	contains RenderPassInfo[1..1] renderPassInfo
	Vector3d graphicOffset = "0;0;0"
	@GenModel(propertyDescription="Field of View in degree ]0 ; 360[")
	float fieldOfViewY = "45"
}

interface IGraphicsPipeline extends IPipeline
{
}

interface IGUIPipeline extends IGraphicsPipeline
{
}

abstract class AbstractGraphicsPipeline extends AbstractPipeline, IGraphicsPipeline
{
	refers unique Shader[1..*] shaders
	contains ViewportState[1..1] viewportState
	contains InputAssembly[1..1] inputAssembly
	contains Rasterizer[1..1] rasterizer
	contains ColorBlend[1..1] colorBlend
	contains DynamicState dynamicState
	int subpass = "0"
}

class GraphicsPipeline extends AbstractGraphicsPipeline
{
}

class DynamicState
{
	EDynamicState[] states
}

class ColorBlend
{
	contains ColorBlendAttachment[] attachments
	boolean logicOpEnable = "false"
	ELogicOp logicOp = "COPY"
	int blendConstant0 = "0"
	int blendConstant1 = "0"
	int blendConstant2 = "0"
	int blendConstant3 = "1"
}

class ColorBlendAttachment
{
	@GenModel(propertyCategory="1 - Common")
	boolean blendEnable = "false"
	@GenModel(propertyCategory="2 - Operation")
	EBlendFactor srcColor = "ONE"
	@GenModel(propertyCategory="2 - Operation")
	EBlendFactor dstColor = "ZERO"
	@GenModel(propertyCategory="2 - Operation")
	EBlendFactor srcAlpha = "ONE"
	@GenModel(propertyCategory="2 - Operation")
	EBlendFactor dstAlpha = "ZERO"
	@GenModel(propertyCategory="2 - Operation")
	EBlendOp colorBlendOp = "ADD"
	@GenModel(propertyCategory="2 - Operation")
	EBlendOp alphaBlendOp = "ADD"
	@GenModel(propertyCategory="3 - Component")
	boolean redComponentEnable = "true"
	@GenModel(propertyCategory="3 - Component")
	boolean greenComponentEnable = "true"
	@GenModel(propertyCategory="3 - Component")
	boolean blueComponentEnable = "true"
	@GenModel(propertyCategory="3 - Component")
	boolean alphaComponentEnable = "true"
}

interface ViewportState
{
}

class StaticViewportState extends ViewportState
{
	contains Viewport[] viewports
	contains Scissor[] scissors
}

class DynamicViewportState extends ViewportState
{
	int viewportCount
	int scissorCount
}

class Viewport
{
	Vector2i offset = "0, 0"
	// If null, will use the swapchain image size
	Vector2i extent
	int minDepth = "0"
	int maxDepth = "1"
}

class Scissor
{
	Vector2i offset = "0, 0"
	// If null, will use the swapchain image size
	Vector2i extent
}

class Rasterizer
{
	ECullMode cullMode = "BACK_BIT"
	EFrontFace frontFace = "CLOCKWISE"
	EPolygonMode polygonMode = "FILL"
	int lineWidth = "1"
	boolean depthClampEnable = "false"
	boolean discardEnable = "false"
	boolean depthBiasEnable = "false"
}

class InputAssembly
{
	boolean primitiveRestartEnabled = "false"
	EPrimitiveTopology primitiveTopology = "TRIANGLE_LIST"
}

class ImagePipeline extends AbstractPipeline
{
	refers Image[1..1] image
	EPipelineStage imageSrcStage
	EPipelineStage imageDstStage
	unique EAccess[] imageSrcAccessMask
	unique EAccess[] imageDstAccessMask
	refers AbstractProcess srcQueue
}
