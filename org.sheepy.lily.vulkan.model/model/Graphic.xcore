@GenModel(cleanup="true", codeFormatting="true")
@GenModel(modelDirectory="/org.sheepy.lily.vulkan.model/src/generated/java")
@GenModel(editDirectory="/org.sheepy.lily.vulkan.model.edit/src/generated/java")
@GenModel(publicConstructors="true", complianceLevel="11.0", resource="XMI")
@GenModel(extensibleProviderFactory="true", childCreationExtenders="true")
@GenModel(updateClasspath="false")
package org.sheepy.lily.vulkan.model.process.graphic

import org.sheepy.lily.core.model.builder.Buildable
import org.sheepy.lily.core.model.types.Color4f
import org.sheepy.lily.core.model.types.LNamedElement
import org.sheepy.lily.vulkan.model.process.AbstractProcess
import org.sheepy.lily.vulkan.model.process.Configuration
import org.sheepy.lily.vulkan.model.process.IPipeline
import org.sheepy.lily.vulkan.model.process.IPipelineTask
import org.sheepy.lily.vulkan.model.resource.Buffer
import org.sheepy.lily.vulkan.model.resource.Image
import org.sheepy.lily.vulkan.model.resource.Shader
import org.sheepy.vulkan.model.barrier.AbstractImageBarrier
import org.sheepy.vulkan.model.enumeration.EAccess
import org.sheepy.vulkan.model.enumeration.EAttachmentLoadOp
import org.sheepy.vulkan.model.enumeration.EAttachmentStoreOp
import org.sheepy.vulkan.model.enumeration.EColorSpace
import org.sheepy.vulkan.model.enumeration.EFormat
import org.sheepy.vulkan.model.enumeration.EImageLayout
import org.sheepy.vulkan.model.enumeration.EImageUsage
import org.sheepy.vulkan.model.enumeration.EIndexType
import org.sheepy.vulkan.model.enumeration.EPipelineStage
import org.sheepy.vulkan.model.enumeration.EPresentMode
import org.sheepy.vulkan.model.enumeration.ESampleCount
import org.sheepy.vulkan.model.graphicpipeline.ColorBlend
import org.sheepy.vulkan.model.graphicpipeline.DynamicState
import org.sheepy.vulkan.model.graphicpipeline.InputAssembly
import org.sheepy.vulkan.model.graphicpipeline.Rasterizer
import org.sheepy.vulkan.model.graphicpipeline.ViewportState

class GraphicConfiguration extends Configuration
{
	contains SwapchainConfiguration[1..1] swapchainConfiguration
	contains FramebufferConfiguration[1..1] framebufferConfiguration
	@GenModel(propertyDescription="The stage on which we should wait until acquire the next image")
	EPipelineStage acquireWaitStage = "COLOR_ATTACHMENT_OUTPUT_BIT"
	contains ColorDomain[1..1] colorDomain
}

class ColorDomain
{
	EFormat format = "B8G8R8A8_UNORM"
	EColorSpace colorSpace = "SRGB_NONLINEAR_KHR"
}

class SwapchainConfiguration
{
	EPresentMode presentationMode = "MailBox"
	int requiredSwapImageCount = "3"
	unique EImageUsage[] swapImageUsages
	contains ISwapAttachment[] atachments
}

class FramebufferConfiguration
{
	Color4f clearValue = "0;0;0;0"
}

interface ISwapAttachment
{
}

class ImageAttachment extends ISwapAttachment
{
	Color4f clearValue = "0;0;0;0"
	refers Image imageRef
}

class DepthAttachment extends ISwapAttachment
{
	boolean clear = "true"
}

class RenderPassInfo
{
	contains AttachmentDescription[] attachments
	contains Subpass[] subpasses
	contains SubpassDependency[] dependencies
	int bindPoint = "0"
}

class Subpass
{
	String name
	contains AttachementRef[] refs
}

class AttachementRef
{
	refers AttachmentDescription attachement
	EImageLayout layout
}

class SubpassDependency
{
	refers Subpass srcSubpass
	refers Subpass dstSubpass
	unique EPipelineStage[] srcStageMask
	unique EPipelineStage[] dstStageMask
	unique EAccess[] srcAccesses
	unique EAccess[] dstAccesses
}

abstract class AttachmentDescription extends LNamedElement
{
	ESampleCount samples
	EAttachmentLoadOp loadOp
	EAttachmentStoreOp storeOp
	EAttachmentLoadOp stencilLoadOp
	EAttachmentStoreOp stencilStoreOp
	EImageLayout initialLayout
	EImageLayout finalLayout
}

class SwapImageAttachmentDescription extends AttachmentDescription
{
}

class ExtraAttachmentDescription extends AttachmentDescription
{
	refers ISwapAttachment[1..1] attachment
}

class GraphicProcess extends AbstractProcess
{
	contains GraphicConfiguration[1..1] configuration
	contains RenderPassInfo[1..1] renderPassInfo
//	Vector3d graphicOffset = "0;0;0"
	@GenModel(propertyDescription="Field of View in degree ]0 ; 360[")
	float fieldOfViewY = "45"
}

class GraphicsPipeline extends IPipeline, Buildable<GraphicsPipeline>
{
	refers unique Shader[1..*] shaders
	contains ViewportState[1..1] viewportState
	contains InputAssembly[1..1] inputAssembly
	contains Rasterizer[1..1] rasterizer
	contains ColorBlend[1..1] colorBlend
	contains DynamicState dynamicState
	int subpass = "0"

	contains VertexDescriptor[1..1] vertexDescriptor
}

class SwapImageBarrier extends AbstractImageBarrier
{
}

class BlitToSwapImage extends IPipelineTask
{
	refers Image[1..1] image
}

class DrawIndexed extends IPipelineTask
{
	int[1..1] indexCount
	int instanceCount = "1"
	int firstIndex = "0"
	int vertexOffset = "0"
	int firstInstance = "0"
}

class Draw extends IPipelineTask
{
	int[1..1] vertexCount
	int instanceCount = "1"
	int firstVertex = "0"
	int firstInstance = "0"
}

class VertexDescriptor
{
	contains AttributeDescription[1..*] attributes

	@GenModel(propertyDescription="Size of a vertex in bytes")
	int strideLength
}

class AttributeDescription
{
	EFormat format
	int offset
}

class IndexedVertexDescriptor extends VertexDescriptor
{
	EIndexType indexType
}

class BindVertexBuffer extends IPipelineTask
{
	int firstBinding = "0"
	contains VertexBinding[1..*] vertexBindings
}

class SetScissor extends IPipelineTask
{
	int offsetX = "0"
	int offsetY = "0"
	int width
	int height
}

class SetViewport extends IPipelineTask
{
	float x = "0"
	float y = "0"
	float width
	float height
	float minDepth = "1"
	float maxDepth = "1"
}

class VertexBinding
{
	refers Buffer[1..1] buffer
	long offset = "0"
}

class BindIndexBuffer extends IPipelineTask
{
	refers Buffer[1..1] buffer
	long offset = "0"
}
